<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Generic recursive lambda in C++14 | YSMILES HOME</title><meta name=keywords content="C++,lambda"><meta name=description content="When we practice LeetCode questions, we always need to write a helper recursive function outside the main solution function. For example, to find the max value in a binary tree, we can have the following codes: (method-1)
class Solution { // pre-order DFS void helper(TreeNode *root, int &ret) { if (!root) return; ret = std::max(ret, root->val); helper(root->left); helper(root->right); } public: int findMax(TreeNode *root) { int maxval = std::numeric_limits<int>::min(); helper(root, maxval); return maxval; } }; Sometimes we don&rsquo;t want to write the helper outside our working function, i."><meta name=author content="Frederick"><link rel=canonical href=gh.ysmiles.com/posts/generic-recursive-lambda-in-c++14/><link crossorigin=anonymous href=/gh.ysmiles.com/assets/css/stylesheet.ddbf7219471e1126282438a902837d962a32b41ca0eb0fdcbea41bcd83b8d308.css integrity="sha256-3b9yGUceESYoJDipAoN9lioytByg6w/cvqQbzYO40wg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/gh.ysmiles.com/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=/images/favicon.ico><link rel=icon type=image/png sizes=16x16 href=gh.ysmiles.com/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=gh.ysmiles.com/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=/images/yun-da.png><link rel=mask-icon href=/images/yun-da.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Generic recursive lambda in C++14"><meta property="og:description" content="When we practice LeetCode questions, we always need to write a helper recursive function outside the main solution function. For example, to find the max value in a binary tree, we can have the following codes: (method-1)
class Solution { // pre-order DFS void helper(TreeNode *root, int &ret) { if (!root) return; ret = std::max(ret, root->val); helper(root->left); helper(root->right); } public: int findMax(TreeNode *root) { int maxval = std::numeric_limits<int>::min(); helper(root, maxval); return maxval; } }; Sometimes we don&rsquo;t want to write the helper outside our working function, i."><meta property="og:type" content="article"><meta property="og:url" content="gh.ysmiles.com/posts/generic-recursive-lambda-in-c++14/"><meta property="og:image" content="gh.ysmiles.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2018-04-19T00:00:00+00:00"><meta property="article:modified_time" content="2018-04-19T00:00:00+00:00"><meta property="og:site_name" content="ysmiles homepage"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="gh.ysmiles.com/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Generic recursive lambda in C++14"><meta name=twitter:description content="When we practice LeetCode questions, we always need to write a helper recursive function outside the main solution function. For example, to find the max value in a binary tree, we can have the following codes: (method-1)
class Solution { // pre-order DFS void helper(TreeNode *root, int &ret) { if (!root) return; ret = std::max(ret, root->val); helper(root->left); helper(root->right); } public: int findMax(TreeNode *root) { int maxval = std::numeric_limits<int>::min(); helper(root, maxval); return maxval; } }; Sometimes we don&rsquo;t want to write the helper outside our working function, i."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"gh.ysmiles.com/posts/"},{"@type":"ListItem","position":3,"name":"Generic recursive lambda in C++14","item":"gh.ysmiles.com/posts/generic-recursive-lambda-in-c++14/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Generic recursive lambda in C++14","name":"Generic recursive lambda in C\u002b\u002b14","description":"When we practice LeetCode questions, we always need to write a helper recursive function outside the main solution function. For example, to find the max value in a binary tree, we can have the following codes: (method-1)\nclass Solution { // pre-order DFS void helper(TreeNode *root, int \u0026amp;ret) { if (!root) return; ret = std::max(ret, root-\u0026gt;val); helper(root-\u0026gt;left); helper(root-\u0026gt;right); } public: int findMax(TreeNode *root) { int maxval = std::numeric_limits\u0026lt;int\u0026gt;::min(); helper(root, maxval); return maxval; } }; Sometimes we don\u0026rsquo;t want to write the helper outside our working function, i.","keywords":["C++","lambda"],"articleBody":"When we practice LeetCode questions, we always need to write a helper recursive function outside the main solution function. For example, to find the max value in a binary tree, we can have the following codes: (method-1)\nclass Solution { // pre-order DFS void helper(TreeNode *root, int \u0026ret) { if (!root) return; ret = std::max(ret, root-\u003eval); helper(root-\u003eleft); helper(root-\u003eright); } public: int findMax(TreeNode *root) { int maxval = std::numeric_limits\u003cint\u003e::min(); helper(root, maxval); return maxval; } }; Sometimes we don’t want to write the helper outside our working function, i.e. findMax in previous example. The reasons can be different. For me, I don’t want to add the reference type parameter ret. In fact, for questions in LeetCode, we always need to add many reference type parameters, such as problems related to backtracking. Since C++11, we can write lambda, further more, recursive lambda locally. This relies on the standard function type. (method-2)\nclass Solution { public: int findMax(TreeNode *root) { int maxval = std::numeric_limits\u003cint\u003e::min(); // pre-order DFS function\u003cvoid(TreeNode*)\u003e helper = [\u0026](TreeNode *root) { if (!root) return; maxval = std::max(ret, root-\u003eval); helper(root-\u003eleft); helper(root-\u003eright); }; helper(root); return maxval; } }; In the code above, [\u0026] indicates the helper lambda to capture the local variables (by references) before the statement. Actually, for the inside call of helper, it also references the name of itself. That’s why we cannot change function to auto. If we use auto, the call to helper inside the function body will make it impossible for compiler to deduce the type of helper.\nBut we really do not want function, because it is too long and it has the same content as (TreeNode *root) later. The reason we want to write lambda is to reduce length, but method-2 seems to make it longer (actually running time also becomes longer).\nLuckily, since C++14, we have a better way to do it, that is the generic lambda. We still cannot use helper inside the lambda body for same reason. But taking advantages of generic parameter, here we have a more tricky way to do it. (method-3)\nclass Solution { public: int findMax(TreeNode *root) { int maxval = std::numeric_limits\u003cint\u003e::min(); // pre-order DFS auto helper = [\u0026](auto \u0026\u0026self, auto root) { if (!root) return; maxval = std::max(ret, root-\u003eval); self(self, root-\u003eleft); self(self, root-\u003eright); }; helper(helper, root); return maxval; } }; This code can successfully compile and result in relatively same runtime efficiency as method-1. We avoid the call to helper inside the body. Instead, we introduce an r-value reference parameter called self. In this way, compiler can deduce out the type of helper when we call it later by helper(helper, root).\nauto \u0026\u0026self can also be const auto \u0026self to fit both l-value and r-value.\nThe reason why method-2 is slightly slower than method-1 and method-3 might be that capture by [\u0026] has more overheads than directly pass the r-value reference argument. For more details, please refer to the reference links below.\nReferences Recursive lambda functions in C++14 - Stack Overflow\nRecursive lambdas in C++(14) - Pedro Melendez\n","wordCount":"499","inLanguage":"en","datePublished":"2018-04-19T00:00:00Z","dateModified":"2018-04-19T00:00:00Z","author":{"@type":"Person","name":"Frederick"},"mainEntityOfPage":{"@type":"WebPage","@id":"gh.ysmiles.com/posts/generic-recursive-lambda-in-c++14/"},"publisher":{"@type":"Organization","name":"YSMILES HOME","logo":{"@type":"ImageObject","url":"/images/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=gh.ysmiles.com accesskey=h title="ysmiles (Alt + H)"><img src=/images/yun-da.png alt aria-label=logo height=35>ysmiles</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=gh.ysmiles.com/gh.ysmiles.com/about title="About me"><span>About me</span></a></li><li><a href=gh.ysmiles.com/gh.ysmiles.com/tags title=Tags><span>Tags</span></a></li><li><a href=gh.ysmiles.com/gh.ysmiles.com/search title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=gh.ysmiles.com>Home</a>&nbsp;»&nbsp;<a href=gh.ysmiles.com/posts/>Posts</a></div><h1 class=post-title>Generic recursive lambda in C++14</h1><div class=post-meta><span title='2018-04-19 00:00:00 +0000 UTC'>April 19, 2018</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;Frederick</div></header><div class=post-content><p>When we practice LeetCode questions, we always need to write a helper recursive function outside the main solution function.
For example, to find the max value in a binary tree, we can have the following codes: (method-1)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// pre-order DFS
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>helper</span>(TreeNode <span style=color:#f92672>*</span>root, <span style=color:#66d9ef>int</span> <span style=color:#f92672>&amp;</span>ret) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>root)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        ret <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>max(ret, root<span style=color:#f92672>-&gt;</span>val);
</span></span><span style=display:flex><span>        helper(root<span style=color:#f92672>-&gt;</span>left);
</span></span><span style=display:flex><span>        helper(root<span style=color:#f92672>-&gt;</span>right);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> findMax(TreeNode <span style=color:#f92672>*</span>root) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> maxval <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>numeric_limits<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;::</span>min();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        helper(root, maxval);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> maxval;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Sometimes we don&rsquo;t want to write the helper outside our working function,
i.e. <code>findMax</code> in previous example.
The reasons can be different.
For me, I don&rsquo;t want to add the reference type parameter <code>ret</code>.
In fact, for questions in LeetCode, we always need to add many reference type parameters, such as problems related to backtracking.
Since C++11, we can write lambda, further more, recursive lambda locally.
This relies on the standard function type. (method-2)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> findMax(TreeNode <span style=color:#f92672>*</span>root) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> maxval <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>numeric_limits<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;::</span>min();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// pre-order DFS
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        function<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>void</span>(TreeNode<span style=color:#f92672>*</span>)<span style=color:#f92672>&gt;</span> helper <span style=color:#f92672>=</span> [<span style=color:#f92672>&amp;</span>](TreeNode <span style=color:#f92672>*</span>root) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>root)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>            maxval <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>max(ret, root<span style=color:#f92672>-&gt;</span>val);
</span></span><span style=display:flex><span>            helper(root<span style=color:#f92672>-&gt;</span>left);
</span></span><span style=display:flex><span>            helper(root<span style=color:#f92672>-&gt;</span>right);
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        helper(root);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> maxval;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>In the code above, <code>[&]</code> indicates the <code>helper</code> lambda to capture the local variables (by references) before the statement.
Actually, for the inside call of <code>helper</code>, it also references the name of itself.
That&rsquo;s why we cannot change <code>function&lt;void(TreeNode*)></code> to <code>auto</code>.
If we use <code>auto</code>, the call to <code>helper</code> inside the function body will make it impossible for compiler to deduce the type of helper.</p><p>But we really do not want <code>function&lt;void(TreeNode*)></code>, because it is too long and it has the same content as <code>(TreeNode *root)</code> later.
The reason we want to write lambda is to reduce length, but method-2 seems to make it longer (actually running time also becomes longer).</p><p>Luckily, since C++14, we have a better way to do it, that is the generic lambda.
We still cannot use <code>helper</code> inside the lambda body for same reason.
But taking advantages of generic parameter, here we have a more tricky way to do it. (method-3)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> findMax(TreeNode <span style=color:#f92672>*</span>root) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> maxval <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>numeric_limits<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;::</span>min();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// pre-order DFS
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>auto</span> helper <span style=color:#f92672>=</span> [<span style=color:#f92672>&amp;</span>](<span style=color:#66d9ef>auto</span> <span style=color:#f92672>&amp;&amp;</span>self, <span style=color:#66d9ef>auto</span> root) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>root)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>            maxval <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>max(ret, root<span style=color:#f92672>-&gt;</span>val);
</span></span><span style=display:flex><span>            self(self, root<span style=color:#f92672>-&gt;</span>left);
</span></span><span style=display:flex><span>            self(self, root<span style=color:#f92672>-&gt;</span>right);
</span></span><span style=display:flex><span>        };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        helper(helper, root);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> maxval;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>This code can successfully compile and result in relatively same runtime efficiency as method-1.
We avoid the call to <code>helper</code> inside the body.
Instead, we introduce an r-value reference parameter called <code>self</code>.
In this way, compiler can deduce out the type of helper when we call it later by <code>helper(helper, root)</code>.</p><p><code>auto &&self</code> can also be <code>const auto &self</code> to fit both l-value and r-value.</p><p>The reason why method-2 is slightly slower than method-1 and method-3 might be that capture by <code>[&]</code> has more overheads than directly pass the r-value reference argument.
For more details, please refer to the reference links below.</p><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><p><a href=https://stackoverflow.com/questions/18085331/recursive-lambda-functions-in-c14>Recursive lambda functions in C++14 - Stack Overflow</a></p><p><a href=http://pedromelendez.com/blog/2015/07/16/recursive-lambdas-in-c14/>Recursive lambdas in C++(14) - Pedro Melendez</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=gh.ysmiles.com/tags/c++/>C++</a></li><li><a href=gh.ysmiles.com/tags/lambda/>lambda</a></li></ul><nav class=paginav><a class=prev href=gh.ysmiles.com/posts/python-basics-for-algorithm-practices/><span class=title>« Prev</span><br><span>Python basics for algorithm practices</span></a>
<a class=next href=gh.ysmiles.com/posts/differences-between-an-interface-and-abstract-class/><span class=title>Next »</span><br><span>Differences between an interface and abstract class</span></a></nav></footer><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//ysmiles.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><nav id=TableOfContents><h2></h2><nav id=TableOfContents><ul><li><a href=#references>References</a></li></ul></nav></nav></article></main><footer class=footer><span>&copy; 2023 <a href=gh.ysmiles.com>YSMILES HOME</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>